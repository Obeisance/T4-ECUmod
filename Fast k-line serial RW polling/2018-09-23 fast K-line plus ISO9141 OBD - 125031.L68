00031030 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 5/10/2020 5:50:33 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : ISO-9141 + fast serial integration
00000000                             3  * Written by : Lotus/mod by Obeisance
00000000                             4  * Date       : 2018-09-23
00000000                             5  * Description: This code replicates the Lotus code at 0x22ada
00000000                             6  *              and adds in an additional mode initialization
00000000                             7  *              that allows for fast serial data responses with
00000000                             8  *              formatting different from OBD response routines
00000000                             9  *-----------------------------------------------------------
00031030                            10      ORG    $31030
00031030  =00081168                 11  Serial_receive_buffer EQU $81168
00031030  =000811E8                 12  Serial_send_buffer EQU $811e8
00031030  =000807BC                 13  OBD_init_level EQU $807bc
00031030  =000807C8                 14  Serial_received_byte_count EQU $807c8
00031030  =000807CA                 15  Num_serial_bytes_left_to_read EQU $807ca
00031030  =000807CC                 16  Serial_send_buffer_byte_count EQU $807cc
00031030  =000807CE                 17  Serial_send_buffer_index EQU $807ce
00031030  =000807D0                 18  Checksum_calc_buffer EQU $807d0
00031030  =000807D2                 19  OBD_timeout_counter_5ms_multiple EQU $807d2
00031030  =000807D8                 20  OBD_continue_response_counter EQU $807d8
00031030  =00080838                 21  DTC_sent_via_OBD_count EQU $80838
00031030  =00080D4A                 22  OBD_mode_0x9_msgs_sent EQU $80d4a
00031030  =0002E506                 23  OBD_mode_0x9_resp_cont EQU $2e506
00031030  =0002351E                 24  OBD_Mode_0x1_resp EQU $2351e
00031030  =00023F7A                 25  OBD_Mode_0x2_resp EQU $23f7a
00031030  =00025746                 26  OBD_Mode_0x3_resp EQU $25746
00031030  =000258EA                 27  OBD_Mode_0x4_resp EQU $258ea
00031030  =0002621A                 28  OBD_Mode_0x5_resp EQU $2621a
00031030  =00028016                 29  OBD_Mode_0x6_resp EQU $28016
00031030  =00028646                 30  OBD_Mode_0x7_resp EQU $28646
00031030  =0002E7C4                 31  OBD_Mode_0x8_resp EQU $2e7c4
00031030  =0002DEE0                 32  OBD_Mode_0x9_resp EQU $2dee0
00031030  =00027F90                 33  OBD_Mode_not_supported EQU $27f90
00031030  =00024400                 34  OBD_Mode_0x22_resp EQU $24400
00031030  =000269C2                 35  OBD_Mode_0x2F_resp EQU $269c2
00031030  =0002EB30                 36  OBD_Mode_0x3B_resp EQU $2eb30
00031030  =00FFFC08                 37  SCCR0 EQU $fffc08
00031030  =00FFFC0A                 38  SCCR1 EQU $fffc0a
00031030  =00FFFC0C                 39  SCSR EQU $fffc0c
00031030  =00FFFC0E                 40  SCDR EQU $fffc0e
00031030                            41   
00031030                            42  START:                  ; first instruction of program
00031030                            43  
00031030                            44  * Put program code here
00031030                            45  
00031030                            46  ; Copy much of the OBD serial response subroutine at 0x022ada
00031030                            47  ; I made changes so that the code is more compact
00031030  4E56 FFE6                 48      LINK A6,#-26
00031034  48EF 3C04 0004            49      MOVEM.L A5/A4/A3/A2/D2,($4,A7)
0003103A  45F9 00081168             50      LEA Serial_receive_buffer,A2    ; OBD incoming serial packet buffer
00031040  47F9 000807D0             51      LEA Checksum_calc_buffer,A3 ; Checksum calculation buffer
00031046  49F9 000807C8             52      LEA Serial_received_byte_count,A4   ; Number of serial bytes received
0003104C  4BF9 000807D2             53      LEA OBD_timeout_counter_5ms_multiple,A5   ; OBD timeout counter - 5 millisecond multiple
00031052  4EB9 00025880             54      JSR ($25880).L  ; update byte at ($80834).L depending on DTC count
00031058  1039 000807BC             55      MOVE.B (OBD_init_level).L,D0    ; Load the OBD init level counter
0003105E  0C00 0009                 56      CMPI.B #9,D0
00031062  6200 046A                 57      BHI end_OBD_routine ; end routine if the init level is too high
00031066  4880                      58      EXT.W D0
00031068  D040                      59      ADD.W D0,D0
0003106A  303B 0006                 60      MOVE.W (*+$2+$6,PC,D0.W),D0
0003106E                            61  jump_start
0003106E  4EFB 0002                 62      JMP (*+$2+$2,PC,D0.W)   ; jump to end routine if OBD init level is not 9 
00031072= 045C                      63      DC.W end_OBD_routine-jump_start-$4
00031074= 045C                      64      DC.W end_OBD_routine-jump_start-$4
00031076= 045C                      65      DC.W end_OBD_routine-jump_start-$4
00031078= 045C                      66      DC.W end_OBD_routine-jump_start-$4
0003107A= 045C                      67      DC.W end_OBD_routine-jump_start-$4
0003107C= 045C                      68      DC.W end_OBD_routine-jump_start-$4
0003107E= 045C                      69      DC.W end_OBD_routine-jump_start-$4
00031080= 045C                      70      DC.W end_OBD_routine-jump_start-$4
00031082= 045C                      71      DC.W end_OBD_routine-jump_start-$4
00031084= 0018                      72      DC.W check_OBD_mode-jump_start-$4  ;if OBD init mode is 9, then we continue in the routine
00031086  6000 0446                 73      BRA.W end_OBD_routine
0003108A                            74  check_OBD_mode
0003108A  0C14 0005                 75      CMPI.B #5,(A4)  ; we always have at least 5 bytes in an OBD query, so we will not proceed until we have collected at least 5 bytes
0003108E  6500 03F0                 76      BCS.W check_error_states    ; branch if we don't have enough bytes
00031092  0C12 0068                 77      CMPI.B #104,(A2)     ; check for correct packet structure [104 106 241 MODE PID checksum]
00031096  6600 0392                 78      BNE.W incorrect_structure_for_ISO_9141
0003109A  0C2A 006A 0001            79      CMPI.B #106,($1,A2)
000310A0  6600 0388                 80      BNE.W incorrect_structure_for_ISO_9141
000310A4  0C2A 00F1 0002            81      CMPI.B #241,($2,A2)
000310AA  6600 037E                 82      BNE.W incorrect_structure_for_ISO_9141
000310AE                            83      ;****Mode 0x1****
000310AE  0C2A 0001 0003            84      CMPI.B #1,($3,A2)
000310B4  6628                      85      BNE.B Mode_0x2
000310B6  0C14 0006                 86      CMPI.B #6,(A4)
000310BA  6500 0412                 87      BCS.W end_OBD_routine
000310BE  4EB9 000314D8             88      JSR (Calc_checksum).L   ; this works without passing in variables because the number of bytes to read and buffer location are fixed in memory
000310C4  B03C 0001                 89      CMP.B #1,D0 ; If D0 = 0, we have a bad checksum
000310C8  6600 0350                 90      BNE.W end_OBD_Mode_response
000310CC  7000                      91      MOVEQ #0,D0
000310CE  102A 0004                 92      MOVE.B ($4,A2),D0
000310D2  2E80                      93      MOVE.L D0,(A7)
000310D4  4EB9 0002351E             94      JSR (OBD_Mode_0x1_resp).L
000310DA  6000 033E                 95      BRA.W end_OBD_Mode_response
000310DE                            96  Mode_0x2
000310DE  0C2A 0002 0003            97      CMPI.B #2,($3,A2)
000310E4  6632                      98      BNE.B Mode_0x3
000310E6  0C14 0007                 99      CMPI.B #7,(A4)
000310EA  6500 03E2                100      BCS.W end_OBD_routine
000310EE  4EB9 000314D8            101      JSR (Calc_checksum).L
000310F4  B03C 0001                102      CMP.B #1,D0
000310F8  6600 0320                103      BNE.W end_OBD_Mode_response
000310FC  7000                     104      MOVEQ #0,D0
000310FE  102A 0005                105      MOVE.B ($5,A2),D0
00031102  2E80                     106      MOVE.L D0,(A7)
00031104  7000                     107      MOVEQ #0,D0
00031106  102A 0004                108      MOVE.B ($4,A2),D0
0003110A  2F00                     109      MOVE.L D0,-(A7)
0003110C  4EB9 00023F7A            110      JSR (OBD_Mode_0x2_resp).L
00031112  588F                     111      ADDQ.L #4,A7    ; Adjust stack pointer back to original position
00031114  6000 0304                112      BRA.W end_OBD_Mode_response
00031118                           113  Mode_0x3
00031118  0C2A 0003 0003           114      CMPI.B #3,($3,A2)
0003111E  6620                     115      BNE.B Mode_0x4
00031120  4EB9 000314D8            116      JSR (Calc_checksum).L
00031126  B03C 0001                117      CMP.B #1,D0
0003112A  6600 02EE                118      BNE.W end_OBD_Mode_response
0003112E  4EB9 00025746            119      JSR (OBD_Mode_0x3_resp).L
00031134  13FC 0009 000807D8       120      MOVE.B #9,(OBD_continue_response_counter).L ; Allow this mode to have multiple response packets
0003113C  6000 02DC                121      BRA.W end_OBD_Mode_response
00031140                           122  Mode_0x4
00031140  0C2A 0004 0003           123      CMPI.B #4,($3,A2)
00031146  6618                     124      BNE.B Mode_0x5
00031148  4EB9 000314D8            125      JSR (Calc_checksum).L
0003114E  B03C 0001                126      CMP.B #1,D0
00031152  6600 02C6                127      BNE.W end_OBD_Mode_response
00031156  4EB9 000258EA            128      JSR (OBD_Mode_0x4_resp).L
0003115C  6000 02BC                129      BRA.W end_OBD_Mode_response
00031160                           130  Mode_0x5
00031160  0C2A 0005 0003           131      CMPI.B #5,($3,A2)
00031166  6632                     132      BNE.B Mode_0x6
00031168  0C14 0007                133      CMPI.B #7,(A4)
0003116C  6500 0360                134      BCS.W end_OBD_routine
00031170  4EB9 000314D8            135      JSR (Calc_checksum).L
00031176  B03C 0001                136      CMP.B #1,D0
0003117A  6600 029E                137      BNE.W end_OBD_Mode_response
0003117E  7000                     138      MOVEQ #0,D0
00031180  102A 0005                139      MOVE.B ($5,A2),D0
00031184  2E80                     140      MOVE.L D0,(A7)
00031186  7000                     141      MOVEQ #0,D0
00031188  102A 0004                142      MOVE.B ($4,A2),D0
0003118C  2F00                     143      MOVE.L D0,-(A7)
0003118E  4EB9 0002621A            144      JSR (OBD_Mode_0x5_resp).L
00031194  588F                     145      ADDQ.L #4,A7
00031196  6000 0282                146      BRA.W end_OBD_Mode_response
0003119A                           147  Mode_0x6
0003119A  0C2A 0006 0003           148      CMPI.B #6,($3,A2)
000311A0  6628                     149      BNE.B Mode_0x7
000311A2  0C14 0006                150      CMPI.B #6,(A4)
000311A6  6500 0326                151      BCS.W end_OBD_routine
000311AA  4EB9 000314D8            152      JSR (Calc_checksum).L
000311B0  B03C 0001                153      CMP.B #1,D0
000311B4  6600 0264                154      BNE.W end_OBD_Mode_response
000311B8  7000                     155      MOVEQ #0,D0
000311BA  102A 0004                156      MOVE.B ($4,A2),D0
000311BE  2E80                     157      MOVE.L D0,(A7)
000311C0  4EB9 00028016            158      JSR (OBD_Mode_0x6_resp).L
000311C6  6000 0252                159      BRA.W end_OBD_Mode_response
000311CA                           160  Mode_0x7
000311CA  0C2A 0007 0003           161      CMPI.B #7,($3,A2)
000311D0  6620                     162      BNE.B Mode_0x8
000311D2  4EB9 000314D8            163      JSR (Calc_checksum).L
000311D8  B03C 0001                164      CMP.B #1,D0
000311DC  6600 023C                165      BNE.W end_OBD_Mode_response
000311E0  7000                     166      MOVEQ #0,D0
000311E2  102A 0004                167      MOVE.B ($4,A2),D0
000311E6  2E80                     168      MOVE.L D0,(A7)
000311E8  4EB9 00028646            169      JSR (OBD_Mode_0x7_resp).L
000311EE  6000 022A                170      BRA.W end_OBD_Mode_response
000311F2                           171  Mode_0x8
000311F2  0C2A 0008 0003           172      CMPI.B #8,($3,A2)
000311F8  6628                     173      BNE.B Mode_0x9
000311FA  0C14 000B                174      CMPI.B #11,(A4) ; must have 11 bytes in a mode 0x8 packet!
000311FE  6500 02CE                175      BCS.W end_OBD_routine
00031202  4EB9 000314D8            176      JSR (Calc_checksum).L
00031208  B03C 0001                177      CMP.B #1,D0
0003120C  6600 020C                178      BNE.W end_OBD_Mode_response
00031210  7000                     179      MOVEQ #0,D0
00031212  102A 0004                180      MOVE.B ($4,A2),D0
00031216  2E80                     181      MOVE.L D0,(A7)
00031218  4EB9 0002E7C4            182      JSR (OBD_Mode_0x8_resp).L
0003121E  6000 01FA                183      BRA.W end_OBD_Mode_response
00031222                           184  Mode_0x9
00031222  0C2A 0009 0003           185      CMPI.B #9,($3,A2)
00031228  6630                     186      BNE.B Mode_0xA
0003122A  0C14 0006                187      CMPI.B #6,(A4)
0003122E  6500 029E                188      BCS.W end_OBD_routine
00031232  4EB9 000314D8            189      JSR (Calc_checksum).L
00031238  B03C 0001                190      CMP.B #1,D0
0003123C  6600 01DC                191      BNE.W end_OBD_Mode_response
00031240  7000                     192      MOVEQ #0,D0
00031242  102A 0004                193      MOVE.B ($4,A2),D0
00031246  2E80                     194      MOVE.L D0,(A7)
00031248  4EB9 0002DEE0            195      JSR (OBD_Mode_0x9_resp).L
0003124E  13FC 0009 000807D8       196      MOVE.B #9,(OBD_continue_response_counter).L
00031256  6000 01C2                197      BRA.W end_OBD_Mode_response
0003125A                           198  Mode_0xA
0003125A  0C2A 000A 0003           199      CMPI.B #10,($3,A2)
00031260  6520                     200      BCS.B Mode_0x22
00031262  0C2A 0021 0003           201      CMPI.B #33,($3,A2)
00031268  6218                     202      BHI.B Mode_0x22
0003126A  4EB9 000314D8            203      JSR (Calc_checksum).L
00031270  B03C 0001                204      CMP.B #1,D0
00031274  6600 01A4                205      BNE.W end_OBD_Mode_response
00031278  4EB9 00027F90            206      JSR (OBD_Mode_not_supported).L
0003127E  6000 019A                207      BRA.W end_OBD_Mode_response
00031282                           208  Mode_0x22
00031282  0C2A 0022 0003           209      CMPI.B #34,($3,A2)
00031288  663E                     210      BNE.B Mode_0x23
0003128A  0C14 0007                211      CMPI.B #7,(A4)
0003128E  6500 023E                212      BCS.W end_OBD_routine
00031292  4EB9 000314D8            213      JSR (Calc_checksum).L
00031298  B03C 0001                214      CMP.B #1,D0
0003129C  6600 017C                215      BNE.W end_OBD_Mode_response
000312A0  7000                     216      MOVEQ #0,D0 ; Collect the two PID bytes from the packet, put them on D0
000312A2  102A 0004                217      MOVE.B ($4,A2),D0
000312A6  4840                     218      SWAP D0
000312A8  4240                     219      CLR.W D0
000312AA  4840                     220      SWAP D0
000312AC  E180                     221      ASL.L #8,D0
000312AE  7200                     222      MOVEQ #0,D1
000312B0  122A 0005                223      MOVE.B ($5,A2),D1
000312B4  4841                     224      SWAP D1
000312B6  4241                     225      CLR.W D1
000312B8  4841                     226      SWAP D1
000312BA  D081                     227      ADD.L D1,D0
000312BC  2E80                     228      MOVE.L D0,(A7)
000312BE  4EB9 00024400            229      JSR (OBD_Mode_0x22_resp).L
000312C4  6000 0154                230      BRA.W end_OBD_Mode_response
000312C8                           231  Mode_0x23
000312C8  0C2A 0023 0003           232      CMPI.B #35,($3,A2)
000312CE  6520                     233      BCS.B Mode_0x2F
000312D0  0C2A 002E 0003           234      CMPI.B #46,($3,A2)
000312D6  6218                     235      BHI.B Mode_0x2F
000312D8  4EB9 000314D8            236      JSR (Calc_checksum).L
000312DE  B03C 0001                237      CMP.B #1,D0
000312E2  6600 0136                238      BNE.W end_OBD_Mode_response
000312E6  4EB9 00027F90            239      JSR (OBD_Mode_not_supported).L
000312EC  6000 012C                240      BRA.W end_OBD_Mode_response
000312F0                           241  Mode_0x2F
000312F0  0C2A 002F 0003           242      CMPI.B #47,($3,A2)
000312F6  6600 00A0                243      BNE.W Mode_0x3B
000312FA  0C14 0007                244      CMPI.B #7,(A4)
000312FE  6500 01CE                245      BCS.W end_OBD_routine
00031302  0C2A 0001 0004           246      CMPI.B #1,($4,A2)   ; check for a valid PID structure
00031308  6646                     247      BNE.B long_Mode_0x2F_PID
0003130A  102A 0005                248      MOVE.B ($5,A2),D0
0003130E  0200 001F                249      ANDI.B #31,D0
00031312  663C                     250      BNE.B long_Mode_0x2F_PID
00031314  4EB9 000314D8            251      JSR (Calc_checksum).L
0003131A  B03C 0001                252      CMP.B #1,D0
0003131E  6600 00FA                253      BNE.W end_OBD_Mode_response
00031322  7000                     254      MOVEQ #0,D0
00031324  2E80                     255      MOVE.L D0,(A7)
00031326  7000                     256      MOVEQ #0,D0 ; Collect the two PID bytes from the packet, put them on D0
00031328  102A 0004                257      MOVE.B ($4,A2),D0
0003132C  4840                     258      SWAP D0
0003132E  4240                     259      CLR.W D0
00031330  4840                     260      SWAP D0
00031332  E180                     261      ASL.L #8,D0
00031334  7200                     262      MOVEQ #0,D1
00031336  122A 0005                263      MOVE.B ($5,A2),D1
0003133A  4841                     264      SWAP D1
0003133C  4241                     265      CLR.W D1
0003133E  4841                     266      SWAP D1
00031340  D081                     267      ADD.L D1,D0
00031342  2F00                     268      MOVE.L D0,-(A7)
00031344  4EB9 000269C2            269      JSR (OBD_Mode_0x2F_resp).L
0003134A  588F                     270      ADDQ.L #4,A7
0003134C  6000 00CC                271      BRA.W end_OBD_Mode_response
00031350                           272  long_Mode_0x2F_PID
00031350  0C14 0008                273      CMPI.B #8,(A4)
00031354  6500 0178                274      BCS.W end_OBD_routine
00031358  4EB9 000314D8            275      JSR (Calc_checksum).L
0003135E  B03C 0001                276      CMP.B #1,D0
00031362  6600 00B6                277      BNE.W end_OBD_Mode_response
00031366  7000                     278      MOVEQ #0,D0
00031368  102A 0006                279      MOVE.B ($6,A2),D0
0003136C  2E80                     280      MOVE.L D0,(A7)
0003136E  7000                     281      MOVEQ #0,D0 ; Collect the two PID bytes from the packet, put them on D0
00031370  102A 0004                282      MOVE.B ($4,A2),D0
00031374  4840                     283      SWAP D0
00031376  4240                     284      CLR.W D0
00031378  4840                     285      SWAP D0
0003137A  E180                     286      ASL.L #8,D0
0003137C  7200                     287      MOVEQ #0,D1
0003137E  122A 0005                288      MOVE.B ($5,A2),D1
00031382  4841                     289      SWAP D1
00031384  4241                     290      CLR.W D1
00031386  4841                     291      SWAP D1
00031388  D081                     292      ADD.L D1,D0
0003138A  2F00                     293      MOVE.L D0,-(A7)
0003138C  4EB9 000269C2            294      JSR (OBD_Mode_0x2F_resp).L
00031392  588F                     295      ADDQ.L #4,A7
00031394  6000 0084                296      BRA.W end_OBD_Mode_response
00031398                           297  Mode_0x3B
00031398  0C2A 003B 0003           298      CMPI.B #59,($3,A2)
0003139E  6654                     299      BNE.B Higher_Modes
000313A0  0C14 000B                300      CMPI.B #11,(A4)
000313A4  6500 0128                301      BCS.W end_OBD_routine
000313A8  4EB9 000314D8            302      JSR (Calc_checksum).L
000313AE  B03C 0001                303      CMP.B #1,D0
000313B2  6600 0066                304      BNE.W end_OBD_Mode_response
000313B6  7000                     305      MOVEQ #0,D0 ; now move 6 bytes onto the stack
000313B8  102A 0009                306      MOVE.B ($9,A2),D0
000313BC  2E80                     307      MOVE.L D0,(A7)
000313BE  7000                     308      MOVEQ #0,D0
000313C0  102A 0008                309      MOVE.B ($8,A2),D0
000313C4  2F00                     310      MOVE.L D0,-(A7)
000313C6  7000                     311      MOVEQ #0,D0
000313C8  102A 0007                312      MOVE.B ($7,A2),D0
000313CC  2F00                     313      MOVE.L D0,-(A7)
000313CE  7000                     314      MOVEQ #0,D0
000313D0  102A 0006                315      MOVE.B ($6,A2),D0
000313D4  2F00                     316      MOVE.L D0,-(A7)
000313D6  7000                     317      MOVEQ #0,D0
000313D8  102A 0005                318      MOVE.B ($5,A2),D0
000313DC  2F00                     319      MOVE.L D0,-(A7)
000313DE  7000                     320      MOVEQ #0,D0
000313E0  102A 0004                321      MOVE.B ($4,A2),D0
000313E4  2F00                     322      MOVE.L D0,-(A7)
000313E6  4EB9 0002EB30            323      JSR (OBD_Mode_0x3B_resp).L
000313EC  4FEF 0014                324      LEA ($14,A7),A7
000313F0  6000 0028                325      BRA.W end_OBD_Mode_response
000313F4                           326  Higher_Modes
000313F4  0C2A 003C 0003           327      CMPI.B #60,($3,A2)  ; Use mode 0x3C as a baud rate toggle, no PID needed
000313FA  6618                     328      BNE.B mode_not_present
000313FC  4EB9 000314D8            329      JSR (Calc_checksum).L
00031402  B03C 0001                330      CMP.B #1,D0
00031406  6600 0012                331      BNE.W end_OBD_Mode_response
0003140A  4EB9 00031508            332      JSR (OBD_Mode_0x3C_resp).L
00031410  6000 0008                333      BRA.W end_OBD_Mode_response
00031414                           334  mode_not_present
00031414  4EB9 00027F90            335      JSR (OBD_Mode_not_supported).L
0003141A                           336  end_OBD_Mode_response
0003141A  4214                     337      CLR.B (A4)
0003141C  4239 000807CA            338      CLR.B (Num_serial_bytes_left_to_read).L
00031422  3ABC 03E8                339      MOVE.W #1000,(A5)
00031426  6000 00A6                340      BRA.W end_OBD_routine
0003142A                           341  incorrect_structure_for_ISO_9141
0003142A                           342  ;************ This is the place to patch in custom code! ***************
0003142A  0C12 0055                343      CMPI.B #85,(A2) ; look for the special packet header byte
0003142E  6644                     344      BNE.B no_correct_packet_structure
00031430  0C2A 0080 0001           345      CMPI.B #128,($1,A2) ; Make sure that the incoming packet is not too big
00031436  623C                     346      BHI.B no_correct_packet_structure
00031438  7000                     347      MOVEQ #0,D0
0003143A  102A 0001                348      MOVE.B ($1,A2),D0
0003143E  B014                     349      CMP.B (A4),D0           ; compare "num bytes received" in (A4) to what the packet says it should contain
00031440  6600 008C                350      BNE.W end_OBD_routine   ; do nothing more until we've read in the entire packet
00031444  0C14 0008                351      CMPI.B #8,(A4)          ; every one of these special packets will have at least 8 bytes [85, #bytes_in_packet, cmd, #bytes_for_command_interest, addr0, addr1, addr3, sum]
00031448  602A                     352      BRA.B no_correct_packet_structure   ; we'll double check this, in case someone sends a malformed packet
0003144A  0C2A 0011 0002           353      CMPI.B #17,($2,A2)
00031450  670A                     354      BEQ.B process_special_cmd
00031452  0C2A 0088 0002           355      CMPI.B #136,($2,A2)
00031458  6702                     356      BEQ.B process_special_cmd
0003145A  6018                     357      BRA.B no_correct_packet_structure
0003145C                           358  process_special_cmd
0003145C  4EB9 000314D8            359      JSR (Calc_checksum).L
00031462  B03C 0001                360      CMP.B #1,D0
00031466  6600 FFB2                361      BNE.W end_OBD_Mode_response
0003146A  4EB9 00031644            362      JSR (special_serial_resp).L
00031470  6000 FFA8                363      BRA.W end_OBD_Mode_response
00031474                           364  ;************** End of new K-line response code ************************
00031474                           365  no_correct_packet_structure
00031474  4214                     366      CLR.B (A4)   ; reset the index to read received data in the buffer
00031476  4239 000807CA            367      CLR.B (Num_serial_bytes_left_to_read).L
0003147C  3ABC 03E8                368      MOVE.W #1000,(A5)   ; reset the 5 sec timeout            
00031480                           369  check_error_states
00031480  4A39 000807CC            370      TST.B (Serial_send_buffer_byte_count).L
00031486  6646                     371      BNE.B end_OBD_routine
00031488  4A39 000807CE            372      TST.B (Serial_send_buffer_index).L
0003148E  663E                     373      BNE.B end_OBD_routine
00031490  4A39 000807D8            374      TST.B (OBD_continue_response_counter).L
00031496  6636                     375      BNE.B end_OBD_routine
00031498  4A39 00080838            376      TST.B (DTC_sent_via_OBD_count).L
0003149E  6710                     377      BEQ.B check_mode_0x9_response
000314A0  4EB9 00025746            378      JSR (OBD_mode_0x3_resp).L
000314A6  13FC 0009 000807D8       379      MOVE.B #9,(OBD_continue_response_counter).L
000314AE  601E                     380      BRA.B end_OBD_routine
000314B0                           381  check_mode_0x9_response
000314B0  4A39 00080D4A            382      TST.B (OBD_mode_0x9_msgs_sent).L
000314B6  6716                     383      BEQ.B end_OBD_routine
000314B8  7000                     384      MOVEQ #0,D0
000314BA  102A 0004                385      MOVE.B ($4,A2),D0
000314BE  2E80                     386      MOVE.L D0,(A7)
000314C0  4EB9 0002E506            387      JSR (OBD_mode_0x9_resp_cont).L
000314C6  13FC 0009 000807D8       388      MOVE.B #9,(OBD_continue_response_counter).L
000314CE                           389  end_OBD_routine
000314CE  4CEF 3C04 0004           390      MOVEM.L ($4,A7),A5/A4/A3/A2/D2
000314D4  4E5E                     391      UNLK A6
000314D6  4E75                     392      RTS
000314D8                           393  
000314D8                           394  
000314D8                           395  Calc_checksum
000314D8  4213                     396      CLR.B (A3)
000314DA  7400                     397      MOVEQ #0,D2
000314DC  1414                     398      MOVE.B (A4),D2  ; number of bytes in the receveived data buffer
000314DE  5302                     399      SUBI.B #1,D2  ; index of final checksum byte
000314E0  600A                     400      BRA.B checksum_loop_cond_check
000314E2                           401  checksum_loop_start
000314E2  5302                     402      SUBI.B #1,D2
000314E4  1002                     403      MOVE.B D2,D0
000314E6  1232 0800                404      MOVE.B ($0,A2,D0.L),D1  ; Load a byte from the packet
000314EA  D313                     405      ADD.B D1,(A3)   ; Add this to the checksum
000314EC                           406  checksum_loop_cond_check
000314EC  0C02 0000                407      CMPI.B #0,D2
000314F0  66F0                     408      BNE.B checksum_loop_start
000314F2  7000                     409      MOVEQ #0,D0
000314F4  1014                     410      MOVE.B (A4),D0
000314F6  5300                     411      SUBI.B #1,D0
000314F8  1232 0800                412      MOVE.B ($0,A2,D0.L),D1 
000314FC  B213                     413      CMP.B (A3),D1
000314FE  6604                     414      BNE.B bad_checksum
00031500  7001                     415      MOVEQ #1,D0
00031502  6002                     416      BRA.B end_checksum
00031504                           417  bad_checksum
00031504  7000                     418      MOVEQ #0,D0
00031506                           419  end_checksum
00031506  4E75                     420      RTS
00031508                           421      
00031508                           422  OBD_Mode_0x3C_resp
00031508  3039 00FFFC08            423      MOVE.W (SCCR0).L,D0
0003150E  0C40 003C                424      CMPI.W #60,D0           ; check to see if we're at 10419 baud
00031512  6600 009E                425      BNE switch_to_10400     ; if not, then switch to 10419 baud
00031516  13FC 0048 000811E8       426      MOVE.B #72,($811e8).L   ; Assemble a fixed packet
0003151E  13FC 006B 000811E9       427      MOVE.B #107,($811e9).L
00031526  13FC 0010 000811EA       428      MOVE.B #16,($811ea).L
0003152E  13FC 007C 000811EB       429      MOVE.B #124,($811eb).L
00031536  13FC 0031 000811EC       430      MOVE.B #$31,($811ec).L  ; we're going to change to 125031 baud after we send this message
0003153E  13FC 0032 000811ED       431      MOVE.B #$32,($811ed).L
00031546  13FC 0035 000811EE       432      MOVE.B #$35,($811ee).L
0003154E  13FC 0030 000811EF       433      MOVE.B #$30,($811ef).L
00031556  13FC 0033 000811F0       434      MOVE.B #$33,($811f0).L
0003155E  13FC 0031 000811F1       435      MOVE.B #$31,($811f1).L
00031566  13FC 006B 000811F2       436      MOVE.B #107,($811f2).L
0003156E  13FC 000A 000807CC       437      MOVE.B #10,(Serial_send_buffer_byte_count).L
00031576  4239 000807CE            438      CLR.B (Serial_send_buffer_index).L
0003157C  7000                     439      MOVEQ #0,D0
0003157E  1039 000811E8            440      MOVE.B (Serial_send_buffer).L,D0
00031584  33C0 00FFFC0E            441      MOVE.W D0,(SCDR).L
0003158A                           442  check_serial_status
0003158A  7000                     443      MOVEQ #0,D0
0003158C  1039 000807CC            444      MOVE.B (Serial_send_buffer_byte_count).L,D0
00031592  4A00                     445      TST.B D0
00031594  66F4                     446      BNE.B check_serial_status   ; loop until we're done sending data
00031596  33FC 0000 00FFFC0A       447      MOVE.W #0,(SCCR1).L    ; Disable the serial comms
0003159E  33FC 0005 00FFFC08       448      MOVE.W #5,(SCCR0).L    ; Change the baud rate to 1: 625156.3; 2: 312578.1; 3: 208385.4; 4: 156289.1; 5: 125031.3; 6: 104192.7, etc.
000315A6  33FC 002C 00FFFC0A       449      MOVE.W #44,(SCCR1).L    ; Enable the serial comms
000315AE  6000 0092                450      BRA end_chg_baud
000315B2                           451  switch_to_10400
000315B2  13FC 0048 000811E8       452      MOVE.B #72,($811e8).L   ; Assemble a fixed packet
000315BA  13FC 006B 000811E9       453      MOVE.B #107,($811e9).L
000315C2  13FC 0010 000811EA       454      MOVE.B #16,($811ea).L
000315CA  13FC 007C 000811EB       455      MOVE.B #124,($811eb).L
000315D2  13FC 0031 000811EC       456      MOVE.B #$31,($811ec).L  ; we're going to change to 10419 baud after we send this message
000315DA  13FC 0030 000811ED       457      MOVE.B #$30,($811ed).L
000315E2  13FC 0034 000811EE       458      MOVE.B #$34,($811ee).L
000315EA  13FC 0031 000811EF       459      MOVE.B #$31,($811ef).L
000315F2  13FC 0039 000811F0       460      MOVE.B #$39,($811f0).L
000315FA  13FC 003E 000811F1       461      MOVE.B #62,($811f1).L
00031602  13FC 0009 000807CC       462      MOVE.B #9,(Serial_send_buffer_byte_count).L
0003160A  4239 000807CE            463      CLR.B (Serial_send_buffer_index).L
00031610  7000                     464      MOVEQ #0,D0
00031612  1039 000811E8            465      MOVE.B (Serial_send_buffer).L,D0
00031618  33C0 00FFFC0E            466      MOVE.W D0,(SCDR).L
0003161E                           467  check_serial_status_2
0003161E  7000                     468      MOVEQ #0,D0
00031620  1039 000807CC            469      MOVE.B (Serial_send_buffer_byte_count).L,D0
00031626  4A00                     470      TST.B D0
00031628  66F4                     471      BNE.B check_serial_status_2   ; loop until we're done sending data
0003162A  33FC 0000 00FFFC0A       472      MOVE.W #0,(SCCR1).L    ; Disable the serial comms
00031632  33FC 003C 00FFFC08       473      MOVE.W #60,(SCCR0).L    ; Change the baud rate to 10419.27
0003163A  33FC 002C 00FFFC0A       474      MOVE.W #44,(SCCR1).L    ; Enable the serial comms
00031642                           475  end_chg_baud
00031642  4E75                     476      RTS
00031644                           477  
00031644                           478  special_serial_resp ; This function can only work with the above serial routine due to reliance on address register population
00031644                           479                      ; so far, we have only guaranteed to have read in 8 bytes
00031644  4E56 FFE4                480      LINK A6,#-28
00031648  48EF 031E 0004           481      MOVEM.L A1/A0/D4/D3/D2/D1,($4,A7)
0003164E  41F9 000811E8            482      LEA Serial_send_buffer,A0
00031654  4213                     483      CLR.B (A3)   ; let's count up the checksum on this RAM address -> we'll send this with the final outgoing packet
00031656  7200                     484      MOVEQ #0,D1 ; An index into the send packet
00031658  70AA                     485      MOVEQ #170,D0 ; Start building the send packet
0003165A  1180 1800                486      MOVE.B D0,($0,A0,D1.L)
0003165E  D113                     487      ADD.B D0,(A3)
00031660  5401                     488      ADDQ.B #2,D1    ; For now, skip over the 'number of bytes' byte
00031662  0C2A 0011 0002           489      CMPI.B #17,($2,A2)
00031668  6600 0052                490      BNE.W special_write     ; if the command byte is not 17, it is 136 (these two are the only ones which would allow entry to this function)
0003166C                           491      ; Read data from ROM
0003166C  7011                     492      MOVEQ #17,D0
0003166E  1180 1800                493      MOVE.B D0,($0,A0,D1.L)
00031672  D113                     494      ADD.B D0,(A3)
00031674  5201                     495      ADDQ.B #1,D1
00031676  7403                     496      MOVEQ #3,D2 ; An index into the read packet
00031678  6030                     497      BRA.B Read_data_cond_check  ; make sure we have enough bytes in the packet to read an address
0003167A                           498      ; Now process the read data commands in the message
0003167A                           499  Read_data_loop_start
0003167A  2032 2801                500      MOVE.L ($1,A2,D2.L),D0  ; grab the address that we're interested in
0003167E  E080                     501      ASR.L #8,D0             ; get rid of the low byte, that is not part of the address
00031680  0280 00FFFFFF            502      ANDI.L #16777215,D0 ; mask the address to three bytes
00031686  2240                     503      MOVEA.L D0,A1   ; Now we have the address to read from
00031688  1032 2800                504      MOVE.B ($0,A2,D2.L),D0  ; Now we also have the number of bytes to read
0003168C  6000 000E                505      BRA copy_data_cond_check
00031690                           506  copy_data_loop_start
00031690  1619                     507      MOVE.B (A1)+,D3 ; read the requested data
00031692  1183 1800                508      MOVE.B D3,($0,A0,D1.L)  ; put the data in the serial send packet
00031696  D713                     509      ADD.B D3,(A3)   ; update the checksum
00031698  5201                     510      ADDQ.B #1,D1    ; increment our send packet index
0003169A  5300                     511      SUBQ.B #1,D0    ; decrement our 'bytes left to read' counter
0003169C                           512  copy_data_cond_check
0003169C  0C01 007F                513      CMPI.B #127,D1  ; Make sure we are not trying to read too many bytes; check the send packet index, leaving space for the checksum
000316A0  6C6A                     514      BGE.B send_packet
000316A2  0C00 0000                515      CMPI.B #0,D0    ; check to see if we've sent all the required data
000316A6  66E8                     516      BNE.B copy_data_loop_start
000316A8  5802                     517      ADDI.B #4,D2    ; Increment our read index to the next command
000316AA                           518  Read_data_cond_check
000316AA  1614                     519      MOVE.B (A4),D3  ; total number of bytes in the received packet
000316AC  5303                     520      SUBQ.B #1,D3    ; total number of bytes - 1 = index of packet checksum
000316AE  B403                     521      CMP.B D3,D2     ; compare our packet read index to the read buffer checksum index
000316B0  645A                     522      BHS.B send_packet ; if our index is on or past the checksum we'll end and send the packet
000316B2  1802                     523      MOVE.B D2,D4    ; else, check to see if we have enough extra bytes in the packet - groups of four. D2 = packet read index
000316B4  5604                     524      ADDQ.B #3,D4    ; packet read index + 3 = final data byte in the next set of four 
000316B6  B403                     525      CMP.B D3,D2     ; compare our read index + the presumed next 4 bytes to the number of bytes in the read buffer
000316B8  65C0                     526      BLO Read_data_loop_start ; if our index is not on or past the checksum, keep going
000316BA  6050                     527      BRA.B send_packet   ; else, if the index is on or past the checksum, we're finished
000316BC                           528  
000316BC                           529  special_write
000316BC  7088                     530      MOVEQ #136,D0
000316BE  1180 1800                531      MOVE.B D0,($0,A0,D1.L)
000316C2  D113                     532      ADD.B D0,(A3)
000316C4  5201                     533      ADDQ.B #1,D1
000316C6  7403                     534      MOVEQ #3,D2 ; An index into the read packet
000316C8  6032                     535      BRA.B Write_data_cond_check
000316CA                           536      ; Now process the write data commands in the message
000316CA                           537  Write_data_loop_start
000316CA  2032 2801                538      MOVE.L ($1,A2,D2.L),D0
000316CE  E080                     539      ASR.L #8,D0
000316D0  0280 00FFFFFF            540      ANDI.L #16777215,D0 ; mask the address to three bytes
000316D6  2240                     541      MOVEA.L D0,A1   ; Now we have the address to write to
000316D8  1032 2800                542      MOVE.B ($0,A2,D2.L),D0  ; Now we also have the number of bytes to write to that address
000316DC  5802                     543      ADDQ.B #4,D2
000316DE  1614                     544      MOVE.B (A4),D3 
000316E0  9602                     545      SUB.B D2,D3    ; check to see that a sufficient number of bytes is in the packet
000316E2  5303                     546      SUBQ.B #1,D3    ; remove the checksum too
000316E4  B003                     547      CMP.B D3,D0
000316E6  6224                     548      BHI.B send_packet   ; send the response packet if too few bytes exist in the command packet
000316E8  6000 000C                549      BRA write_block_cond_check
000316EC                           550  write_block_loop_start
000316EC  1632 2800                551      MOVE.B ($0,A2,D2.L),D3
000316F0  12C3                     552      MOVE.B D3,(A1)+
000316F2  5300                     553      SUBQ.B #1,D0
000316F4  5202                     554      ADDQ.B #1,D2
000316F6                           555  write_block_cond_check
000316F6  0C00 0000                556      CMPI.B #0,D0    ; check to see if we need to send more bytes
000316FA  66F0                     557      BNE write_block_loop_start    
000316FC                           558  Write_data_cond_check
000316FC  1614                     559      MOVE.B (A4),D3
000316FE  5303                     560      SUBQ.B #1,D3
00031700  B403                     561      CMP.B D3,D2 ; check to see if our read packet index is on or past the checksum
00031702  6408                     562      BHS.B send_packet ; if our index is on or past the checksum we'll end and send the packet
00031704  1802                     563      MOVE.B D2,D4    ; else, check to see if we have enough bytes in the packet
00031706  5604                     564      ADDQ.B #3,D4    ; packet read index + 3 = final data byte in the next set of four (num bytes to send + addr) 
00031708  B403                     565      CMP.B D3,D2     ; compare our read index + the presumed next 4 bytes to the number of bytes in the read buffer
0003170A  65BE                     566      BLO Write_data_loop_start
0003170C                           567  send_packet
0003170C  1601                     568      MOVE.B D1,D3
0003170E  5203                     569      ADDQ.B #1,D3
00031710  1143 0001                570      MOVE.B D3,($1,A0)   ; update the 'number of bytes in packet' byte in the packet
00031714  D713                     571      ADD.B D3,(A3)   ; perform the final checksum update
00031716  1613                     572      MOVE.B (A3),D3  ; then put the checksum into the packet
00031718  1183 1800                573      MOVE.B D3,($0,A0,D1.L)
0003171C  13C1 000807CC            574      MOVE.B D1,(Serial_send_buffer_byte_count).L ; Then set the counters to send the packet
00031722  4239 000807CE            575      CLR.B (Serial_send_buffer_index).L
00031728  7000                     576      MOVEQ #0,D0
0003172A  1039 000811E8            577      MOVE.B (Serial_send_buffer).L,D0
00031730  33C0 00FFFC0E            578      MOVE.W D0,(SCDR).L  ; Then put the first byte from the packet into the buffer in order to send it     
00031736                           579  end_special_ser_routine
00031736  4CEF 031E 0004           580      MOVEM.L ($4,A7),A1/A0/D4/D3/D2/D1
0003173C  4E5E                     581      UNLK A6
0003173E  4E75                     582      RTS
00031740                           583      
00031740  FFFF FFFF                584      SIMHALT             ; halt simulator
00031744                           585  
00031744                           586  * Put variables and constants here
00031744                           587  
00031744                           588      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
BAD_CHECKSUM        31504
CALC_CHECKSUM       314D8
CHECKSUM_CALC_BUFFER  807D0
CHECKSUM_LOOP_COND_CHECK  314EC
CHECKSUM_LOOP_START  314E2
CHECK_ERROR_STATES  31480
CHECK_MODE_0X9_RESPONSE  314B0
CHECK_OBD_MODE      3108A
CHECK_SERIAL_STATUS  3158A
CHECK_SERIAL_STATUS_2  3161E
COPY_DATA_COND_CHECK  3169C
COPY_DATA_LOOP_START  31690
DTC_SENT_VIA_OBD_COUNT  80838
END_CHECKSUM        31506
END_CHG_BAUD        31642
END_OBD_MODE_RESPONSE  3141A
END_OBD_ROUTINE     314CE
END_SPECIAL_SER_ROUTINE  31736
HIGHER_MODES        313F4
INCORRECT_STRUCTURE_FOR_ISO_9141  3142A
JUMP_START          3106E
LONG_MODE_0X2F_PID  31350
MODE_0X2            310DE
MODE_0X22           31282
MODE_0X23           312C8
MODE_0X2F           312F0
MODE_0X3            31118
MODE_0X3B           31398
MODE_0X4            31140
MODE_0X5            31160
MODE_0X6            3119A
MODE_0X7            311CA
MODE_0X8            311F2
MODE_0X9            31222
MODE_0XA            3125A
MODE_NOT_PRESENT    31414
NO_CORRECT_PACKET_STRUCTURE  31474
NUM_SERIAL_BYTES_LEFT_TO_READ  807CA
OBD_CONTINUE_RESPONSE_COUNTER  807D8
OBD_INIT_LEVEL      807BC
OBD_MODE_0X1_RESP   2351E
OBD_MODE_0X22_RESP  24400
OBD_MODE_0X2F_RESP  269C2
OBD_MODE_0X2_RESP   23F7A
OBD_MODE_0X3B_RESP  2EB30
OBD_MODE_0X3C_RESP  31508
OBD_MODE_0X3_RESP   25746
OBD_MODE_0X4_RESP   258EA
OBD_MODE_0X5_RESP   2621A
OBD_MODE_0X6_RESP   28016
OBD_MODE_0X7_RESP   28646
OBD_MODE_0X8_RESP   2E7C4
OBD_MODE_0X9_MSGS_SENT  80D4A
OBD_MODE_0X9_RESP   2DEE0
OBD_MODE_0X9_RESP_CONT  2E506
OBD_MODE_NOT_SUPPORTED  27F90
OBD_TIMEOUT_COUNTER_5MS_MULTIPLE  807D2
PROCESS_SPECIAL_CMD  3145C
READ_DATA_COND_CHECK  316AA
READ_DATA_LOOP_START  3167A
SCCR0               FFFC08
SCCR1               FFFC0A
SCDR                FFFC0E
SCSR                FFFC0C
SEND_PACKET         3170C
SERIAL_RECEIVED_BYTE_COUNT  807C8
SERIAL_RECEIVE_BUFFER  81168
SERIAL_SEND_BUFFER  811E8
SERIAL_SEND_BUFFER_BYTE_COUNT  807CC
SERIAL_SEND_BUFFER_INDEX  807CE
SPECIAL_SERIAL_RESP  31644
SPECIAL_WRITE       316BC
START               31030
SWITCH_TO_10400     315B2
WRITE_BLOCK_COND_CHECK  316F6
WRITE_BLOCK_LOOP_START  316EC
WRITE_DATA_COND_CHECK  316FC
WRITE_DATA_LOOP_START  316CA
